{
package parse_peg
}


Grammar = __ json:Json __ (EOF / SyntaxError) {
    return json, nil
}

// TODO:
// Object
Json = BasicType / Array

Array = "[" __ outter:( ArrayElement OtherArrayElement )? __ "]" {
    if outter == nil {
        return []interface{}{}, nil
    }
    arr := outter.([]interface{})
    finalArr := []interface{}{ arr[0] }
    innerArr, typeOk := arr[1].([]interface{})
    if typeOk {
        finalArr = append(finalArr, innerArr...)
    } else {
        finalArr = append(finalArr, innerArr)
    }

    return finalArr, nil
}

ArrayElement = BasicType / Array

OtherArrayElement = inner:( __ "," __ ArrayElement )* {
    innerArr := inner.([]interface{})
    arr := make([]interface{}, 0, len(innerArr))
    for _, elem := range innerArr {
        elemArr := elem.([]interface{})
        arr = append(arr, elemArr[3])
    }
    return arr, nil
}

BasicType = Boolean / Null / Number / String

// Actions will be seperated by the ChoiceExpr, so use `()`
// ```````````````
// Boolean = ("true" / "false") {
//     return string(c.text) == "true", nil
// }
// ```````````````
// Seems better
Boolean = "true" { return true, nil } / "false" { return false, nil }

Null = "null" {
    return nil, nil
}

// TODO: maybe int32? float32/float64?
Number = [0-9]+ {
    return strconv.ParseInt(string(c.text), 10, 64)
}

String = '"' ( "\\\"" / ( !'"' . ) )* '"' {
    s := string(c.text)
    l := len(s)
    if l < 3 {
        return "", nil
    }
    return s[1:l-1], nil
}

SyntaxError = . {
	return nil, errors.New("parser: syntax error")
}

__ = ( Whitespace / EOL )*

Whitespace = [ \t\r]
EOL = '\n'
EOF = !.
